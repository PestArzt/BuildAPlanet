--[[
    PlantSaveData
    Mod By Lorris (7/12/2025) v.05
    M√≥dulo Data para Save das Plantas
    Connections:
    FarmingService
    DataStoreModule
    ItemData
    InventoryService
    LeaderstatsService
--]]
local PlantSaveData = {}

local DataStoreService = game:GetService("DataStoreService")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")

local DataStoreModule = require(game:GetService("ServerScriptService").Data.DataStoreModule)
local ItemData = require(game:GetService("ServerScriptService").Data.ItemData)
local PlantMutationData = require(game:GetService("ServerScriptService").Data.PlantsMutationData)
local FarmingService

local loadedPlantDataCache = {}

function PlantSaveData:Initialize()
	--print("üå± PlantSaveData (v.04 Corrigido) inicializado")
end

function PlantSaveData:UpdatePlayerPlantData(player)
	local playerPlantsData = {}

	-- FUN√á√ÉO AUXILIAR PARA EVITAR REPETI√á√ÉO DE C√ìDIGO
	local function serializePlantsInContainer(containerModel, containerUUID)
		local plantsFolder = containerModel:FindFirstChild("Plants")
		if not plantsFolder then return end

		local containerPlants = {}
		for _, plantModel in ipairs(plantsFolder:GetChildren()) do
			if plantModel:IsA("Model") and plantModel:GetAttribute("UUID") then
				local containerCFrame = containerModel:GetPivot()
				local plantCFrame = plantModel:GetPivot()
				local relativeCFrame = containerCFrame:ToObjectSpace(plantCFrame)
				local durationsAttr = plantModel:GetAttribute("StageDurations")

				local plantData = {
					UUID = plantModel:GetAttribute("UUID"),
					SeedName = plantModel:GetAttribute("Seed"),
					Category = plantModel:GetAttribute("Category") or "Seeds",
					Owner = plantModel:GetAttribute("Owner"),
					PlantedTime = plantModel:GetAttribute("PlantedTime"),
					CurrentStage = plantModel:GetAttribute("CurrentStage"),
					PlotUUID = containerUUID, 
					RelativeCF = { relativeCFrame:GetComponents() },
					StageDurations = durationsAttr and HttpService:JSONDecode(durationsAttr) or nil,
				
					IsMutated = plantModel:GetAttribute("IsMutated"),
					MutatedName = plantModel:GetAttribute("MutatedName"),
				}
				table.insert(containerPlants, plantData)
			end
		end

		if #containerPlants > 0 then
			playerPlantsData[containerUUID] = containerPlants
		end
	end

	-- Aqui e diretamente nas plots
	for _, plot in ipairs(CollectionService:GetTagged("plot")) do
		if plot:GetAttribute("Owner") == player.Name then
			local plotUUID = plot:GetAttribute("UUID")
			if plotUUID then
				serializePlantsInContainer(plot, plotUUID)
			else
				warn("‚ùå Plot sem UUID, pulando coleta para:", plot.Name)
			end
		end
	end

	-- So a logic do planet
	local playerPlanetModel = nil
	for _, planetFolder in ipairs(workspace.Planets:GetChildren()) do
		if planetFolder:GetAttribute("Owner") == player.Name then
			-- Fun√ß√£o para pegar o modelo "Planet" dentro da pasta
			playerPlanetModel = planetFolder:FindFirstChild("Planet") or planetFolder:FindFirstChildOfClass("Model")
			break
		end
	end

	if playerPlanetModel then
		--identificador especial para as plantas do planeta
		local planetIdentifier = "__PLANET__" 
		serializePlantsInContainer(playerPlanetModel, planetIdentifier)
	end

	local plantsDataStore = DataStoreModule.GetDataStore(player, "PlayerPlants_VOne")
	if plantsDataStore then
		--print(string.format("‚ÑπÔ∏è Preparando dados de plantas para %s. {cache a ser salvo pelo DataStoreModule}", player.Name))
		plantsDataStore:SetData(playerPlantsData)
	else
		warn("‚ùå N√£o foi poss√≠vel encontrar o DataStore de plantas para preparar os dados de", player.Name)
	end
end


function PlantSaveData:LoadPlayerPlants(player)
	print(string.format("üóÇÔ∏è Carregando dados de plantas para %s...", player.Name))
	local plantsDataStore = DataStoreModule.GetDataStore(player, "PlayerPlants_VOne")

	-- O GetData aqui vai esperar pela conclus√£o (gra√ßas √† l√≥gica no DataStoreModule valeu demais pedral)
	local data = plantsDataStore:GetData({}) 

	if data and next(data) then
		loadedPlantDataCache[player.UserId] = data
		print(string.format("‚úÖ Dados de plantas de %s carregados para a cache.", player.Name))
	else
		loadedPlantDataCache[player.UserId] = {}
		print(string.format("‚ÑπÔ∏è Nenhum dado de planta encontrado para %s. Cache inicializada vazia.", player.Name))
	end
end

function PlantSaveData:RestoreAllPlantsForPlayer(player)
	local allPlayerPlantsData = loadedPlantDataCache[player.UserId]
	if not allPlayerPlantsData or not next(allPlayerPlantsData) then
		print(string.format("‚ÑπÔ∏è Nenhuma planta na cache para restaurar para %s.", player.Name))
		return
	end

	local currentTime = os.time()
	for containerUUID, plotPlantsArray in pairs(allPlayerPlantsData) do
		local targetContainer = nil 
		if containerUUID == "__PLANET__" then
			for _, planetFolder in ipairs(workspace.Planets:GetChildren()) do
				if planetFolder:GetAttribute("Owner") == player.Name then
					targetContainer = planetFolder:FindFirstChild("Planet") or planetFolder:FindFirstChildOfClass("Model")
					break
				end
			end
		else
			local plots = CollectionService:GetTagged("plot")
			for _, plot in ipairs(plots) do
				if plot:GetAttribute("UUID") == containerUUID and plot:GetAttribute("Owner") == player.Name then
					targetContainer = plot
					break
				end
			end
		end

		if targetContainer then
			local plantsFolder = targetContainer:FindFirstChild("Plants")
			if not plantsFolder then
				plantsFolder = Instance.new("Folder")
				plantsFolder.Name = "Plants"
				plantsFolder.Parent = targetContainer
			end
			for _, plantData in ipairs(plotPlantsArray) do
				self:RestorePlant(plantData, plantsFolder, currentTime, targetContainer)
			end
		else
			warn(string.format("‚ö†Ô∏è Container de plantas com UUID/ID '%s' n√£o encontrado no workspace para o jogador %s. As plantas n√£o ser√£o restauradas.", containerUUID, player.Name))
		end
	end
end


function PlantSaveData:RestorePlantsForPlot(player, targetPlot)
	--dados diretamente do cache do DataStoreModule
	local plantsDataStore = DataStoreModule.GetDataStore(player, "PlayerPlants_VOne")
	if not plantsDataStore then
		warn("‚ùå DataStore de plantas n√£o inicializado para", player.Name)
		return
	end

	-- O GetData() aqui vai retornar o valor do cache que j√° foi carregado
	local playerPlantsData = plantsDataStore:GetData({})
	if not playerPlantsData then return end -- Se for nil, n√£o h√° nada a restaurar.

	local plotUUID = targetPlot:GetAttribute("UUID")
	if not plotUUID then
		warn("‚ö†Ô∏è Plot", targetPlot.Name, "n√£o tem UUID, n√£o √© poss√≠vel restaurar plantas.")
		return
	end

	local plotPlants = playerPlantsData[plotUUID]
	if not plotPlants or #plotPlants == 0 then
		return
	end

	local currentTime = os.time()
	local plantsFolder = targetPlot:FindFirstChild("Plants")
	if not plantsFolder then
		warn("‚ùå Pasta Plants n√£o encontrada na plot:", targetPlot.Name)
		return
	end

	for _, plantData in ipairs(plotPlants) do
		self:RestorePlant(plantData, plantsFolder, currentTime, targetPlot)
	end
end


function PlantSaveData:RestorePlant(plantData, plantsFolder, currentTime, targetPlot)
	FarmingService = FarmingService or require(game:GetService("ServerScriptService").Game.FarmingService)
	if not plantsFolder or not targetPlot then return end
	local itemCategory = plantData.Category or "Seeds" 
	local seedData = ItemData:GetItem(itemCategory, plantData.SeedName)
	if not seedData then
		warn("‚ùå Dados do item n√£o encontrados ao restaurar:", plantData.SeedName, "na categoria", itemCategory, ". A planta n√£o ser√° restaurada.")
		return
	end
	local stageDurations = plantData.StageDurations 
	if not stageDurations then
		warn("‚ö†Ô∏è Dados de planta antigos detectados para " .. plantData.UUID .. ". Gerando dura√ß√µes dinamicamente.")
		stageDurations = {}
		for i, stageInfo in ipairs(seedData.Stages) do
			local duration = stageInfo.Duration
			if type(duration) == "table" then
				stageDurations[i] = math.random(duration[1], duration[2])
			else

				stageDurations[i] = duration or 0
			end
		end
	end
	local isMutated = plantData.IsMutated and plantData.MutatedName and plantData.MutatedName ~= ""

	local finalStageModel, finalStage, timeIntoCurrentStage

	if isMutated then
		finalStageModel = PlantMutationData:FindMutationModel(plantData.MutatedName) 
		finalStage = #seedData.Stages 
		timeIntoCurrentStage = 0
	else 
		local timeElapsed = currentTime - (plantData.PlantedTime or currentTime)
		local savedStage = plantData.CurrentStage or 1
		local calculatedStage
		calculatedStage, timeIntoCurrentStage = self:CalculateStageFromTime(seedData, timeElapsed, stageDurations)

		finalStage = math.max(savedStage, calculatedStage)
		finalStage = math.max(1, math.min(finalStage, #seedData.Stages))
		finalStageModel = ItemData:FindModel(seedData, finalStage)
	end

	if not finalStageModel then
		warn("‚ùå Modelo n√£o encontrado para o est√°gio", finalStage, "da seed", plantData.SeedName)
		return
	end

	local newPlant = finalStageModel:Clone()
	newPlant.Parent = plantsFolder


	local plotCFrame = targetPlot:GetPivot()
	if plantData.RelativeCF then
		local relativeCFrame = CFrame.new(table.unpack(plantData.RelativeCF))
		newPlant:PivotTo(plotCFrame * relativeCFrame)
	else
		warn("‚ùå Dados de posi√ß√£o da planta ausentes (RelativeCF):", plantData.UUID, ". A planta n√£o ser√° restaurada.")
		newPlant:Destroy()
		return
	end
	newPlant:SetAttribute("UUID", plantData.UUID)
	newPlant:SetAttribute("Seed", plantData.SeedName)
	newPlant:SetAttribute("Owner", plantData.Owner)
	newPlant:SetAttribute("PlantedTime", plantData.PlantedTime)
	newPlant:SetAttribute("CurrentStage", finalStage)
	newPlant:SetAttribute("Category", plantData.Category or "Seeds") 
	newPlant:SetAttribute("StageDurations", HttpService:JSONEncode(stageDurations))
	newPlant:SetAttribute("IsMutated", isMutated)
	newPlant:SetAttribute("MutatedName", plantData.MutatedName or "")


	if finalStage == #seedData.Stages then
		self:AddHarvestPrompt(newPlant, seedData, isMutated, plantData.MutatedName)
	end
	local restoredPlantData = {
		UUID = plantData.UUID,
		Seed = seedData,
		Model = newPlant,
		Owner = plantData.Owner,
		PlantedTime = plantData.PlantedTime,
		CurrentStage = finalStage,
		SoilModel = targetPlot,
		Position = newPlant:GetPivot(),
		StageDurations = stageDurations,
		TimeIntoCurrentStage = (finalStage > (plantData.CurrentStage or 1)) and timeIntoCurrentStage or 0,
		IsMutated = isMutated,
		MutatedName = isMutated and plantData.MutatedName or nil,
	}

	FarmingService:RegisterAndContinueGrowth(restoredPlantData)
end

function PlantSaveData:CalculateStageFromTime(seedData, timeElapsed, stageDurations)
	if not seedData or not seedData.Stages or not stageDurations then
		warn("‚ùå Dados de seed ou dura√ß√µes inv√°lidos para c√°lculo de est√°gio")
		return 1, 0 -- Retorna stage 1 e 0 tempo decorrido
	end

	local timeIntoCurrentStage = math.max(0, timeElapsed)
	local currentStage = 1
	local maxStage = #seedData.Stages

	for stage = 1, maxStage - 1 do
		local duration = stageDurations[stage]
		if not duration then break end

		if timeIntoCurrentStage >= duration then
			timeIntoCurrentStage = timeIntoCurrentStage - duration
			currentStage = stage + 1
		else
			-- se n√£o entrou no if significa que o tempo ainda n√£o passou da dura√ß√£o do est√°gio, ent√£o sai do loop
			break
		end
	end

	-- so pra garantir
	if currentStage >= maxStage then
		currentStage = maxStage
		timeIntoCurrentStage = 0
	end

	return currentStage, timeIntoCurrentStage
end

function PlantSaveData:AddHarvestPrompt(plantModel, seedData, isMutated, mutatedName)
	-- Remover prompts existentes
	for _, existingPrompt in ipairs(plantModel:GetDescendants()) do
		if existingPrompt:IsA("ProximityPrompt") then
			existingPrompt:Destroy()
		end
	end
	-- Criar novo prompt
	local cropInteraction = Instance.new("ProximityPrompt")
	cropInteraction.Parent = plantModel
	cropInteraction.ActionText = "Harvest"
	cropInteraction.ObjectText = seedData.Name
	cropInteraction.HoldDuration = 0.1
	cropInteraction.RequiresLineOfSight = false
	cropInteraction.Style = Enum.ProximityPromptStyle.Custom
	if isMutated and mutatedName then
		cropInteraction.ActionText = "Colher Tesouro"
		cropInteraction.ObjectText = mutatedName
		cropInteraction:SetAttribute("Theme", "StarProx")
	else
	if seedData.Category == "Eggs" then
		cropInteraction.ActionText = "Chocar"
		cropInteraction:SetAttribute("Theme", "EggHatchProx")
	else
		cropInteraction.ActionText = "Harvest"
		cropInteraction:SetAttribute("Theme", "SeedCollectprox")
	end
end
	cropInteraction.Triggered:Connect(function(triggeringPlayer)
		local FarmingService = require(game:GetService("ServerScriptService").Game.FarmingService)
		local plantData = FarmingService.activePlants[plantModel:GetAttribute("UUID")]
		if plantData then
			FarmingService:HarvestPlant(triggeringPlayer, plantData)
		end
	end)
end

function PlantSaveData:SaveAllPlayerPlants()
	for _, player in ipairs(Players:GetPlayers()) do
		self:UpdatePlayerPlantData(player)
	end
end


-- Fun√ß√£o para ser chamada quando uma planta √© removida/colhida
function PlantSaveData:OnPlantRemoved(plantUUID, ownerName)
	local player = Players:FindFirstChild(ownerName)
	if player then
		self:UpdatePlayerPlantData(player)
		local plantsDataStore = DataStoreModule.GetDataStore(player, "PlayerPlants_VOne")
		if plantsDataStore then
			plantsDataStore:SaveData()
		end
	end
end

function PlantSaveData:ClearCacheForPlayer(player)
	if not player then return end
	if loadedPlantDataCache[player.UserId] then
		loadedPlantDataCache[player.UserId] = nil
		print(string.format("üóëÔ∏è Cache de plantas para %s foi limpa ap√≥s o salvamento.", player.Name))
	end
end

return PlantSaveData